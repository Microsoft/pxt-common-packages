#include "pxt.h"

// first reloc, then validate
// image as list of objects
// every loaded pointer has to have metadata! go and read first word
//   - can be valid double
//   - can be relocated pointer to a valid VTable
// reloc - local (within image, just add image pointer) or external (vtables only?)

// TODO reloc entries in the image
// TODO linked list of function stacks
// TODO optimze add/sub/etc
// TODO list of api number->name mapping in the image - resolved at load time
// TODO same for opcodes

// TODO look for patterns in output for combined instructions

namespace pxt {

//%
void op_stloc(FiberContext *ctx, unsigned arg) {
    ctx->sp[arg] = ctx->r0;
}

//%
void op_ldloc(FiberContext *ctx, unsigned arg) {
    ctx->r0 = ctx->sp[arg];
}

//%
void op_stcap(FiberContext *ctx, unsigned arg) {
    ctx->caps[arg] = ctx->r0;
}

//%
void op_ldcap(FiberContext *ctx, unsigned arg) {
    ctx->r0 = ctx->caps[arg];
}

//%
void op_stglb(FiberContext *ctx, unsigned arg) {
    globals[arg] = ctx->r0;
}

//%
void op_ldglb(FiberContext *ctx, unsigned arg) {
    ctx->r0 = globals[arg];
}

//%
void op_ldlit(FiberContext *ctx, unsigned arg) {
    ctx->r0 = ctx->img->pointerLiterals[arg];
}

//%
void op_lddouble(FiberContext *ctx, unsigned arg) {
    ctx->r0 = fromDouble(ctx->img->doubleLiterals[arg]);
}

//%
void op_jmp(FiberContext *ctx, unsigned arg) {
    ctx->pc = ctx->imgbase + arg;
}

//%
void op_jmpfalse(FiberContext *ctx, unsigned arg) {
    if (!toBoolQuick(ctx->r0))
        ctx->pc = ctx->imgbase + arg;
}

//%
void op_jmptrue(FiberContext *ctx, unsigned arg) {
    if (toBoolQuick(ctx->r0))
        ctx->pc = ctx->imgbase + arg;
}

//%
void op_call(FiberContext *ctx, unsigned arg) {
    *--ctx->sp = (TValue)(((ctx->pc - ctx->imgbase) << 8) | 2);
    ctx->pc = ctx->imgbase + arg;
}

//%
void op_ret(FiberContext *ctx, unsigned arg) {
    ctx->sp += arg; // optional popmany
    auto retaddr = (intptr_t)*ctx->sp++;
    ctx->pc = ctx->imgbase + (retaddr >> 8);
}

//%
void op_pop(FiberContext *ctx, unsigned) {
    ctx->r0 = *ctx->sp++;
}

//%
void op_popmany(FiberContext *ctx, unsigned arg) {
    ctx->sp += arg;
}

//%
void op_pushmany(FiberContext *ctx, unsigned arg) {
    while (arg--) {
        *--ctx->sp = TAG_UNDEFINED;
    }
}

//%
void op_push(FiberContext *ctx, unsigned) {
    *--ctx->sp = ctx->r0;
}

//%
void op_ldspecial(FiberContext *ctx, unsigned arg) {
    ctx->r0 = (TValue)(uintptr_t)arg;
}

//%
void op_ldint(FiberContext *ctx, unsigned arg) {
    ctx->r0 = TAG_NUMBER(arg);
}

//%
void op_ldintneg(FiberContext *ctx, unsigned arg) {
    ctx->r0 = TAG_NUMBER(-(int)arg);
}

//%
void op_ldintind(FiberContext *ctx, unsigned arg) {
    ctx->r0 = TAG_NUMBER(ctx->img->intLiterals[arg]);
}

// To be generated by pxt
void call_something(FiberContext *ctx) {
    int a0 = toInt(ctx->r0);
    int a1 = toInt(ctx->sp[0]);

    int r = getConfig(a0, a1);

    ctx->r0 = fromInt(r);
    ctx->sp += 1;
}

void exec_loop(FiberContext *ctx) {
    auto opcodes = ctx->img->opcodes;
    while (ctx->pc) {
        uint32_t opcode = *ctx->pc++;
        if (opcode & OPCODE_BASE_MASK)
            opcodes[opcode & OPCODE_BASE_MASK](ctx, opcode >> OPCODE_BASE_SIZE);
        else
            ((ApiFun)opcodes[opcode >> (32 - OPCODE_API_SIZE)])(ctx);
    }
}

} // namespace pxt