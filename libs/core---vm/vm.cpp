#include "pxt.h"

// TODO optimze add/sub/etc
// TODO look for patterns in output for combined instructions

#define FUNCTION_CODE_OFFSET 8

namespace pxt {

//%
void op_stloc(FiberContext *ctx, unsigned arg) {
    ctx->sp[arg] = ctx->r0;
}

//%
void op_ldloc(FiberContext *ctx, unsigned arg) {
    ctx->r0 = ctx->sp[arg];
}

//%
void op_stcap(FiberContext *ctx, unsigned arg) {
    ctx->caps[arg] = ctx->r0;
}

//%
void op_ldcap(FiberContext *ctx, unsigned arg) {
    ctx->r0 = ctx->caps[arg];
}

//%
void op_stglb(FiberContext *ctx, unsigned arg) {
    globals[arg] = ctx->r0;
}

//%
void op_ldglb(FiberContext *ctx, unsigned arg) {
    ctx->r0 = globals[arg];
}

//%
void op_ldlit(FiberContext *ctx, unsigned arg) {
    ctx->r0 = ctx->img->pointerLiterals[arg];
}

//%
void op_ldnumber(FiberContext *ctx, unsigned arg) {
    ctx->r0 = (TValue)ctx->img->numberLiterals[arg];
}

//%
void op_jmp(FiberContext *ctx, unsigned arg) {
    ctx->pc += (int)arg;
}

//%
void op_jmpz(FiberContext *ctx, unsigned arg) {
    if (!toBoolQuick(ctx->r0))
        ctx->pc += (int)arg;
}

//%
void op_jmpnz(FiberContext *ctx, unsigned arg) {
    if (toBoolQuick(ctx->r0))
        ctx->pc += (int)arg;
}

//%
void op_callproc(FiberContext *ctx, unsigned arg) {
    *--ctx->sp = (TValue)(((ctx->pc - ctx->imgbase) << 8) | 2);
    ctx->pc = (uint16_t *)ctx->img->pointerLiterals[arg] + (FUNCTION_CODE_OFFSET / 2);
}

//%
void op_callind(FiberContext *ctx, unsigned arg) {
    auto fn = ctx->r0;
    if (!isPointer(fn))
        failedCast(fn);
    auto vt = getVTable((RefObject *)fn);
    if (vt->objectType != ValType::Function)
        failedCast(fn);

    if (arg != vt->reserved) {
        // TODO re-arrange the stack, so that the right number
        // of arguments is present
        failedCast(fn);
    }

    *--ctx->sp = (TValue)(((ctx->pc - ctx->imgbase) << 8) | 2);
    ctx->pc = (uint16_t *)fn + 4;
}

//%
void op_ret(FiberContext *ctx, unsigned arg) {
    unsigned numTmps = (arg & 0xf) | ((arg >> 8) & 0xff);
    unsigned numArgs = ((arg >> 4) & 0xf) | ((arg >> 16) & 0xff);
    ctx->sp += numTmps;
    auto retaddr = (intptr_t)*ctx->sp++;
    ctx->sp += numArgs;
    ctx->pc = ctx->imgbase + (retaddr >> 8);
}

//%
void op_pop(FiberContext *ctx, unsigned) {
    ctx->r0 = *ctx->sp++;
}

//%
void op_popmany(FiberContext *ctx, unsigned arg) {
    ctx->sp += arg;
}

//%
void op_pushmany(FiberContext *ctx, unsigned arg) {
    while (arg--) {
        *--ctx->sp = TAG_UNDEFINED;
    }
}

//%
void op_push(FiberContext *ctx, unsigned) {
    *--ctx->sp = ctx->r0;
}

//%
void op_ldspecial(FiberContext *ctx, unsigned arg) {
    ctx->r0 = (TValue)(uintptr_t)arg;
}

//%
void op_ldint(FiberContext *ctx, unsigned arg) {
    ctx->r0 = TAG_NUMBER(arg);
}

//%
void op_ldintneg(FiberContext *ctx, unsigned arg) {
    ctx->r0 = TAG_NUMBER(-(int)arg);
}

// To be generated by pxt
void call_getConfig(FiberContext *ctx) {
    int a0 = toInt(ctx->sp[0]);
    int a1 = toInt(ctx->r0); // last argument in r0

    int r = getConfig(a0, a1);

    ctx->r0 = fromInt(r);
    ctx->sp += 1;
}

const OpcodeDesc staticOpcodes[] = { // list follows
    {"op_push", op_push, 0},
    {"op_pop", op_pop, 0},
    {"op_ldintneg", op_ldintneg, 0},
    {"pxt::getConfig", (OpFun)call_getConfig, 2},
    {NULL, NULL, 0}};

//%
Action fetchMethodIface(TValue obj, int methodId) {
    return NULL;
}

//%
Action fetchMethod(TValue obj, int methodId) {
    return NULL;
}

//%
void stfld(TValue obj, int fieldId, TValue v) {}

//%
TValue ldfld(TValue obj, int fieldId) {
    return NULL;
}

//%
TValue instanceOf(TValue obj, int firstClass, int lastClass) {
    return NULL;
}

//%
void validateInstanceOf(TValue obj, int firstClass, int lastClass) {}

void exec_loop(FiberContext *ctx) {
    auto opcodes = ctx->img->opcodes;
    while (ctx->pc) {
        uint16_t opcode = *ctx->pc++;
        if (opcode >> 15 == 0) {
            opcodes[opcode & OPCODE_BASE_MASK](ctx, opcode >> OPCODE_BASE_SIZE);
        } else if (opcode >> 14 == 0b10) {
            ((ApiFun)opcodes[opcode & 0x3fff])(ctx);
        } else {
            unsigned tmp = ((int32_t)opcode << (16 + 2)) >> (2 + OPCODE_BASE_SIZE);
            opcode = *ctx->pc++;
            opcodes[opcode & OPCODE_BASE_MASK](ctx, (opcode >> OPCODE_BASE_SIZE) + tmp);
        }
    }
}

// 1230
#define FNERR(errcode)                                                                             \
    do {                                                                                           \
        img->errorOffset = (uint8_t *)&code[pc] - (uint8_t *)img->dataStart;                       \
        img->errorCode = errcode;                                                                  \
        return;                                                                                    \
    } while (0)
#define FORCE_STACK(v, errcode, pc)                                                                \
    do {                                                                                           \
        if (stackDepth[pc] && stackDepth[pc] != v)                                                 \
            FNERR(errcode);                                                                        \
        stackDepth[pc] = v;                                                                        \
    } while (0)

void validateFunction(VMImage *img, VMImageSection *sect) {
    uint16_t stackDepth[sect->size / 2];
    memset(stackDepth, 0, sizeof(stackDepth));
    int baseStack = 1; // 1 is the return address; also zero in the array above means unknown yet
    int currStack = baseStack;
    unsigned pc = 0;
    auto code = (uint16_t *)((uint8_t *)sect + FUNCTION_CODE_OFFSET);
    auto lastPC = (sect->size - FUNCTION_CODE_OFFSET) >> 1;
    auto atEnd = false;

    unsigned numArgs = sect->aux;
    unsigned numCaps = 0; // TODO

    while (pc < lastPC) {
        if (currStack > 200)
            FNERR(1204);

        FORCE_STACK(currStack, 1201, pc);

        uint16_t opcode = code[pc++];
        if (opcode == 0 && atEnd)
            continue; // allow padding at the end

        atEnd = false;
        OpFun fn;
        unsigned arg;
        unsigned opIdx;

        if (opcode >> 15 == 0) {
            opIdx = opcode & OPCODE_BASE_MASK;
            arg = opcode >> OPCODE_BASE_SIZE;
        } else if (opcode >> 14 == 0b10) {
            opIdx = opcode & 0x3fff;
            arg = 0;
            if (opIdx >= img->numOpcodes)
                FNERR(1227);
            auto opd = img->opcodeDescs[opIdx];
            if (!opd)
                FNERR(1228);
            if (opd->numArgs > 1) {
                currStack -= opd->numArgs - 1;
                if (currStack < baseStack)
                    FNERR(1229);
            }
            continue;
        } else {
            unsigned tmp = ((int32_t)opcode << (16 + 2)) >> (2 + OPCODE_BASE_SIZE);
            FORCE_STACK(0xffff, 1200, pc); // cannot jump here!
            opcode = code[pc++];
            opIdx = opcode & OPCODE_BASE_MASK;
            arg = (opcode >> OPCODE_BASE_SIZE) + tmp;
        }

        fn = img->opcodes[opIdx];

        if (fn == op_pushmany) {
            if (currStack == 1 && baseStack == 1)
                baseStack = currStack = arg + 1;
            else
                currStack += arg;
        } else if (fn == op_popmany) {
            currStack -= arg;
            if (currStack < baseStack)
                FNERR(1205);
        } else if (fn == op_push) {
            currStack++;
        } else if (fn == op_pop) {
            currStack--;
            if (currStack < baseStack)
                FNERR(1206);
        } else if (fn == op_ret) {
            unsigned numTmps = (arg & 0xf) | ((arg >> 8) & 0xff);
            unsigned retNumArgs = ((arg >> 4) & 0xf) | ((arg >> 16) & 0xff);
            if (currStack != baseStack)
                FNERR(1207);
            if (numTmps + 1 != (unsigned)baseStack)
                FNERR(1208);
            if (retNumArgs != numArgs)
                FNERR(1209);
            currStack = baseStack;
            atEnd = true;
        } else if (fn == op_ldloc || fn == op_stloc) {
            if (arg == (unsigned)currStack - 1)
                FNERR(1210); // trying to load return address
            if (arg >= (unsigned)currStack - 1 + numArgs)
                FNERR(1211);
        } else if (fn == op_ldcap || fn == op_stcap) {
            if (arg >= numCaps)
                FNERR(1212);
        } else if (fn == op_ldglb || fn == op_stglb) {
            if (arg >= img->infoHeader->allocGlobals)
                FNERR(1213);
            // not supported (yet?)
            if (arg < img->infoHeader->nonPointerGlobals)
                FNERR(1214);
        } else if (fn == op_ldlit) {
            if (arg >= img->numSections)
                FNERR(1215);
            if (!img->pointerLiterals[arg])
                FNERR(1216);
        } else if (fn == op_ldnumber) {
            if (arg >= img->numNumberLiterals)
                FNERR(1217);
        } else if (fn == op_callproc) {
            if (arg >= img->numSections)
                FNERR(1218);
            auto fsec = (VMImageSection *)img->pointerLiterals[arg];
            if (!fsec)
                FNERR(1219);
            if (fsec->type != SectionType::Function)
                FNERR(1220);
            unsigned calledArgs = fsec->aux;
            currStack -= calledArgs;
            if (currStack < baseStack)
                FNERR(1221);
        } else if (fn == op_callind) {
            if (arg > 40)
                FNERR(1222);
            currStack -= arg;
            if (currStack < baseStack)
                FNERR(1223);
        } else if (fn == op_ldspecial) {
            auto a = (TValue)(uintptr_t)arg;
            if (a != TAG_TRUE && a != TAG_FALSE && a != TAG_UNDEFINED && a != TAG_UNDEFINED &&
                a != TAG_NAN)
                FNERR(1224);
        } else if (fn == op_ldint || fn == op_ldintneg) {
            // nothing to check!
        } else if (fn == op_jmp || fn == op_jmpnz || fn == op_jmpz) {
            unsigned newPC = pc + arg; // will overflow for backjump
            if (newPC >= lastPC)
                FNERR(1202);
            FORCE_STACK(currStack, 1226, newPC);
            if (fn == op_jmp) {
                if (currStack != baseStack)
                    FNERR(1203);
                atEnd = true;
            }
        } else {
            FNERR(1225);
        }
    }

    if (!atEnd) {
        pc--;
        FNERR(1210);
    }
}

} // namespace pxt