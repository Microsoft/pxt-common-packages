#include "pxt.h"
#include "AnalogSensor.h"
#include "MultiButton.h"

namespace pxt {

class WButtons {
  public:
#define Button codal::Button
    Button buttons[0];
    //% indexedInstanceNS=input indexedInstanceShim=pxt::getButton
    /**
     * Left button.
     */
    //% block="button A" weight=95
    Button buttonA;
    /**
     * Right button.
     */
    //% block="button B" weight=94
    Button buttonB;
#undef Button
// MultiButton has to be last, as it has different size
#define Button codal::MultiButton
    /**
     * Left and Right button.
     */
    //% block="buttons A+B" weight=93
    Button buttonsAB;
#undef Button

    WButtons()
        : buttonA(*pxt::lookupPin(PIN_BTN_A), DEVICE_ID_BUTTON_A, DEVICE_BUTTON_ALL_EVENTS,
                     ACTIVE_HIGH, PullDown),
          buttonB(*pxt::lookupPin(PIN_BTN_B), DEVICE_ID_BUTTON_B, DEVICE_BUTTON_ALL_EVENTS,
                      ACTIVE_HIGH, PullDown),
          buttonsAB(DEVICE_ID_BUTTON_A, DEVICE_ID_BUTTON_B, DEVICE_ID_BUTTON_AB) {}
};
SINGLETON(WButtons);

const int LastButtonID = (Button*)&((WButtons *)0)->buttonsAB - ((WButtons *)0)->buttons;

//%
Button *getButton(int id) {
    if (!(0 <= id && id <= LastButtonID))
        target_panic(42);
    return &getWButtons()->buttons[id];
}
}

//% noRefCounting fixedInstances
namespace ButtonMethods {
/**
 * Do something when a button (`A`, `B` or both `A` + `B`) is clicked, double clicked, etc...
 * @param button the button that needs to be clicked or used
 * @param event the kind of button gesture that needs to be detected
 * @param body code to run when the event is raised
 */
//% help=input/button/on-event
//% blockId=buttonEvent block="on %button|%event"
//% parts="buttonpair"
//% blockNamespace=input
//% button.fieldEditor="gridpicker"
//% button.fieldOptions.width=220
//% button.fieldOptions.columns=3
//% weight=96 blockGap=8
void onEvent(Button_ button, ButtonEvent ev, Action body) {
    if (DEVICE_ID_BUTTON_AB == button->id) {
        // A user has registered to receive events from the buttonAB multibutton.
        // Disable click events from being generated by ButtonA and ButtonB, and defer the
        // control of this to the multibutton handler.
        //
        // This way, buttons look independent unless a buttonAB is requested, at which
        // point button A+B clicks can be correclty handled without breaking
        // causal ordering.        
        getWButtons()->buttonA.setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);
        getWButtons()->buttonB.setEventConfiguration(DEVICE_BUTTON_SIMPLE_EVENTS);        
        getWButtons()->buttonsAB.setEventConfiguration(DEVICE_BUTTON_ALL_EVENTS);
    }
    registerWithDal(button->id, (int)ev, body);
}

/**
 * Check if a button is pressed or not.
 * @param button the button to query the request
 */
//% help=input/button/is-pressed
//% block="%button|is pressed"
//% blockId=buttonIsPressed
//% parts="buttonpair"
//% blockNamespace=input
//% button.fieldEditor="gridpicker"
//% button.fieldOptions.width=220
//% button.fieldOptions.columns=3
//% weight=50 blockGap=8
bool isPressed(Button_ button) {
    return button->isPressed();
}

/**
 * See if the button was pressed again since the last time you checked.
 * @param button the button to query the request
 */
//% help=input/button/was-pressed
//% block="%button|was pressed"
//% blockId=buttonWasPressed
//% parts="buttonpair"
//% blockNamespace=input
//% button.fieldEditor="gridpicker"
//% button.fieldOptions.width=220
//% button.fieldOptions.columns=3
//% group="More" weight=46 blockGap=8
bool wasPressed(Button_ button) {
    return button->wasPressed();
}
}
